// C:\Users\SOHAM\Desktop\crawler\test-crawler\src\functions\ingestion\interfaces.ts

import { GSStatus, GSContext } from '@godspeedsystems/core';
import { EventEmitter } from 'events';

// --- Ingestion Data Structures ---
export interface IngestionData {
    id: string; // Unique identifier for the data item
    content: string | Buffer | object;
    metadata?: { // Optional metadata associated with the data
        [key: string]: any;
        filename?: string; // e.g., original filename
        relativePath?: string; // e.g., path within a source system
    };
    fetchedAt?: Date;
    url?: string;     // Added for HTTP Crawler output
    statusCode?: number; // Added for HTTP Crawler output
    [key: string]: any; // Allows for additional arbitrary properties
}

export type IngestionDataTransformer = (rawData: any[], initialPayload?: any) => Promise<IngestionData[]>;


// --- Plugin Interfaces ---

export interface GSDataSource {
    execute(ctx: GSContext, initialPayload?: any): Promise<GSStatus>;
    initClient(): Promise<any>;
}

export interface IDestinationPlugin {
    init(config: any): Promise<void>; // Initialize with destination-specific config
    processData(data: IngestionData[]): Promise<GSStatus>; // Process a batch of ingested data
}


// --- Task Definition Interfaces ---

export type TriggerType = 'cron' | 'webhook' | 'manual';

export interface BaseTrigger {
    type: TriggerType;
    enabled?: boolean;
}

export interface CronTrigger extends BaseTrigger {
    type: 'cron';
    expression: string; // Cron expression, e.g., "0 0 * * *"
}

export interface WebhookTrigger extends BaseTrigger {
    type: 'webhook';
    credentials: any; // Credentials for source/destination (e.g., API keys, service account JSON)
    callbackurl:string
    endpointId: string; // A unique ID for the webhook endpoint (e.g., '/webhook/gdrive')
    secret?: string; // Secret used for webhook validation (generated by manager, stored in DB)
    externalWebhookId?: string; // ID returned by the external service (e.g., GitHub hook ID, GDrive channel ID)
}

export interface ManualTrigger extends BaseTrigger {
    type: 'manual';
    // No specific properties needed for manual trigger other than 'type'
}

export type IngestionTrigger = CronTrigger | WebhookTrigger | ManualTrigger;

export enum IngestionTaskStatus {
    SCHEDULED = 'SCHEDULED',
    RUNNING = 'RUNNING',
    COMPLETED = 'COMPLETED',
    FAILED = 'FAILED',
    DISABLED = 'DISABLED',
}

export interface IngestionTaskDefinition {
    id: string; // Unique ID for the ingestion task (UUID)
    name: string; // Human-readable name
    description?: string;
    enabled: boolean; // Whether the task is active or not
    trigger: IngestionTrigger;
    source: {
        pluginType: string; // e.g., 's3', 'gdrive-crawler', 'git'
        config: any; // Source-specific configuration
    };
    destination?: { // Destination is optional (e.g., if only transforming data)
        pluginType: string; // e.g., 'filesystem', 'database', 'sftp'
        config: any; // Destination-specific configuration
    };
    // Optional additional properties for task management
    currentStatus?: IngestionTaskStatus;
    lastRun?: Date;
    lastRunStatus?: GSStatus;
    nextRun?: Date; // For cron jobs, calculated next run time
    // Any custom parameters or configurations for the transformer function itself
    transformerParams?: any;

    // Crawler-specific tokens/state that need to be persisted with the task
    startPageToken?: string; // For Google Drive delta syncs
    nextPageToken?: string; // For resumable full scans
    otherCrawlerSpecificTokens?: any; // Flexible field for other crawler-specific state
}

// --- Webhook Registry Entry for Database ---
export interface WebhookRegistryEntry {
    sourceIdentifier: string; // Unique key for the source (e.g., repoUrl, folderId, meetingId)
    endpointId: string; // The local endpoint ID (e.g., '/webhook/gdrive')
    secret: string; // The secret generated by your system for validation
    externalWebhookId: string; // The ID returned by the external service (e.g., GitHub hook ID, GDrive channel ID)
    registeredTasks: string[]; // Array of task IDs using this webhook (for shared webhooks)
    webhookFlag: boolean; // Indicates if an external webhook is currently active for this source

    // Crawler-specific tokens/state that are tied to the webhook registration
    startPageToken?: string; // For Google Drive delta syncs
    nextPageToken?: string; // For resumable full scans
    otherCrawlerSpecificTokens?: any; // Flexible field for other crawler-specific state
}
export interface ProcessedWebhookResult {
    isValid: boolean;
    payload?: any; // The parsed payload from the webhook body
    externalResourceId?: string; // Added: The specific resource ID from the webhook (e.g., repo URL, folder ID)
    changeType?: 'UPSERT' | 'DELETE' | 'UNKNOWN'; // Added: The type of change detected
    error?: string; // Error message if validation fails
}

// --- Database Service Interface ---
export interface IDatabaseService {
    init(): Promise<void>;

    // Task operations
    getTask(taskId: string): Promise<IngestionTaskDefinition | undefined>;
    saveTask(task: IngestionTaskDefinition): Promise<void>;
    updateTask(taskId: string, updates: Partial<IngestionTaskDefinition>): Promise<void>;
    deleteTask(taskId: string): Promise<void>;
    listAllTasks(): Promise<IngestionTaskDefinition[]>;

    // Webhook registration operations
    getWebhookRegistration(sourceIdentifier: string): Promise<WebhookRegistryEntry | undefined>;
    saveWebhookRegistration(entry: WebhookRegistryEntry): Promise<void>;
    updateWebhookRegistration(sourceIdentifier: string, updates: Partial<WebhookRegistryEntry>): Promise<void>;
    deleteWebhookRegistration(sourceIdentifier: string): Promise<void>;
}

// --- Lifecycle Manager Interface ---
export interface IGlobalIngestionLifecycleManager {
    init(): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    registerSource(pluginType: string, sourcePlugin: new (...args: any[]) => GSDataSource, transformer: IngestionDataTransformer): void;
    registerDestination(pluginType: string, destinationPlugin: new (...args: any[]) => IDestinationPlugin): void;
    scheduleTask(taskDefinition: IngestionTaskDefinition): Promise<GSStatus>;
    updateTask(taskId: string, updates: Partial<IngestionTaskDefinition>): Promise<GSStatus>;
    enableTask(taskId: string): Promise<GSStatus>;
    disableTask(taskId: string): Promise<GSStatus>;
    deleteTask(taskId: string): Promise<GSStatus>;
    // MODIFIED: getTask now returns a Promise
    getTask(taskId: string): Promise<IngestionTaskDefinition | undefined>;
    // MODIFIED: listTasks now returns a Promise
    listTasks(): Promise<IngestionTaskDefinition[]>;
    triggerManualTask(ctx: GSContext, taskId: string, initialPayload?: any): Promise<GSStatus>;
    triggerWebhookTask(ctx: GSContext, endpointId: string, payload: any,requestHeaders:any): Promise<GSStatus>;
    triggerAllEnabledCronTasks(ctx: GSContext): Promise<GSStatus>; // This method is now the cron entry point
    getEventBus(): EventEmitter;
    // New method to inject the database service
    setDatabaseService(dbService: IDatabaseService): void;
}

// --- Orchestrator Interface (Optional, but good for explicit typing if used elsewhere) ---
export interface IIngestionOrchestrator {
    executeTask(ctx: GSContext, initialPayload?: any): Promise<GSStatus>;
    getEventBus(): EventEmitter;
}

// --- Events for Ingestion Lifecycle ---
export const IngestionEvents = {
    TASK_SCHEDULED: 'task_scheduled',
    TASK_UPDATED: 'task_updated',
    TASK_ENABLED: 'task_enabled',
    TASK_DISABLED: 'task_disabled',
    TASK_DELETED: 'task_deleted',
    TASK_STARTED: 'task_started',
    TASK_TRIGGERED: 'task_triggered',
    TASK_COMPLETED: 'task_completed',
    TASK_FAILED: 'task_failed',
    DATA_FETCHED: 'data_fetched',
    DATA_TRANSFORMED: 'data_transformed',
    DATA_PROCESSED: 'data_processed',
    // Add more granular events as needed
};
